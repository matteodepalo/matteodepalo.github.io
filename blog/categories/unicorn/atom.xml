<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: unicorn | Matteo Depalo's Blog]]></title>
  <link href="http://matteodepalo.github.io/blog/categories/unicorn/atom.xml" rel="self"/>
  <link href="http://matteodepalo.github.io/"/>
  <updated>2013-09-09T16:54:35+02:00</updated>
  <id>http://matteodepalo.github.io/</id>
  <author>
    <name><![CDATA[Matteo Depalo]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[How I migrated from Heroku to Digital Ocean with Chef and Capistrano]]></title>
    <link href="http://matteodepalo.github.io/blog/2013/03/07/how-i-migrated-from-heroku-to-digital-ocean-with-chef-and-capistrano/"/>
    <updated>2013-03-07T11:24:00+01:00</updated>
    <id>http://matteodepalo.github.io/blog/2013/03/07/how-i-migrated-from-heroku-to-digital-ocean-with-chef-and-capistrano</id>
    <content type="html"><![CDATA[<p>UPDATE:</p>

<ul>
<li>Removed ElasticSearch and MongoDB recipes since they were not so useful for this tutorial.</li>
<li>Added unicorn.rb</li>
<li>Added ssh authentication step</li>
<li>Added file paths</li>
</ul>


<p>I&rsquo;ve always loved deploying to Heroku. The simplicity of a git push let me focus on developing my applications which is what I really care about. However, both because of the <a href="http://rapgenius.com/James-somers-herokus-ugly-secret-lyrics">scandal about the routing system</a> and because I wanted to expand my skill set by entering the sysadmin land, at <a href="https://goresponsa.com">Responsa</a> I decided to migrate to a VPS solution.</p>

<p>At this point I had three choices to make:</p>

<ol>
<li>Hosting provider</li>
<li>Technology stack</li>
<li>Deploy strategy</li>
</ol>


<h2>Provider</h2>

<p>Many hackers I follow were recommending <a href="https://www.digitalocean.com/">Digital Ocean</a> so I gave it a try. I must say I was very impressed with the simplicity and power of their dashboard, so I decided to use it.</p>

<p>I immediately changed my root password</p>

<p><code>
passwd
</code></p>

<p>Copied over my ssh key with</p>

<p><code>
ssh-copy-id root@$IP
</code></p>

<p>And disabled password access setting <code>PasswordAuthentication no</code> in <code>/etc/ssh/sshd_config</code></p>

<h2>Technology</h2>

<p>The decision of the web server was also quick. I wanted to achieve 0 downtime deployments so Github use of <a href="https://github.com/blog/517-unicorn">Unicorn + Nginx</a> jumped to my mind.</p>

<h2>Deploy strategy</h2>

<p>This is where things got a little bit complicated. Disclaimer: I&rsquo;m not a Linux/Unix pro, so many system administration practices where unknown to me prior to this week. Having said that, It was clear to me that the community is very fragmented. There were so many solutions to the same problems and so many scripts! After digging, trying and failing miserably I settled on the stack that caused me the least suffering:</p>

<ol>
<li>Chef solo and Knife for the machine provisioning</li>
<li>Capistrano for the deployment</li>
</ol>


<h2>Chef</h2>

<p><a href="http://www.opscode.com/chef/">Chef</a> is a provisioning tool written in Ruby. Its DSL is very expressive and powerful. The community is full of useful cookbooks that ease the setup of common services, however it seemed to lack a way to handle community cookbooks. This is where <a href="https://github.com/applicationsonline/librarian-chef">Librarian Chef</a> comes in. I just had to write a Cheffile with all the dependencies and I was done.</p>

<p>```ruby</p>

<h1>Cheffile</h1>

<h1>!/usr/bin/env ruby</h1>

<h1>^syntax detection</h1>

<p>site &lsquo;<a href="http://community.opscode.com/api/v1">http://community.opscode.com/api/v1</a>&rsquo;</p>

<p>cookbook &lsquo;libqt4&rsquo;,
  :git => &lsquo;<a href="https://github.com/phlipper/chef-libqt4">https://github.com/phlipper/chef-libqt4</a>&rsquo;</p>

<p>cookbook &lsquo;nodejs&rsquo;
cookbook &lsquo;nginx&rsquo;
cookbook &lsquo;runit&rsquo;
cookbook &lsquo;java&rsquo;
cookbook &lsquo;imagemagick&rsquo;
cookbook &lsquo;vim&rsquo;
cookbook &lsquo;ruby_build&rsquo;, :git => &lsquo;git://github.com/fnichol/chef-ruby_build.git&rsquo;
cookbook &lsquo;rbenv&rsquo;, :git => &lsquo;git://github.com/fnichol/chef-rbenv.git&rsquo;
cookbook &lsquo;redis&rsquo;, :git => &lsquo;git://github.com/cassianoleal/chef-redis.git&rsquo;
cookbook &lsquo;memcached&rsquo;
```</p>

<p>To bootstrap the machine with Chef and Ruby many people where using custom Knife templates that were not working for me. Some installed ruby with RVM, others with rbenv. In the end I found <a href="http://matschaffer.github.com/knife-solo/">Knife Solo</a> that solved all my problems. With one command after the initialization I could install Chef AND run all my recipes to install Ruby and every other service I needed.</p>

<p><code>
knife solo init
knife solo bootstrap root@$IP node.json
</code></p>

<p>Librarian and Knife Solo forced me to use a specific project structure:</p>

<p><code>
mychefrepo/
├── cookbooks
├── site-cookbooks
├── Cheffile
├── Cheffile.lock
└── node.json
</code></p>

<p>The node.json contains the run list of recipes:</p>

<p>```json
{
  &ldquo;user&rdquo;: {</p>

<pre><code>"name": "deployer",
"password": $PASSWORD
</code></pre>

<p>  },
  &ldquo;environment&rdquo;: &ldquo;production&rdquo;,
  &ldquo;server_name&rdquo;: &ldquo;goresponsa.com&rdquo;,
  &ldquo;deploy_to&rdquo;: &ldquo;/var/www/responsa&rdquo;,
  &ldquo;ruby-version&rdquo;: &ldquo;1.9.3-p286&rdquo;,
  &ldquo;run_list&rdquo;: [</p>

<pre><code>"recipe[vim]",
"recipe[libqt4]",
"recipe[imagemagick]",
"recipe[java]",
"recipe[redis::source]",
"recipe[memcached]",
"recipe[nodejs]",
"recipe[ruby_build]",
"recipe[rbenv::system]",
"recipe[runit]",
"recipe[nginx]",
"recipe[main]"
</code></pre>

<p>  ]
}
```</p>

<p>All recipes except the &ldquo;main&rdquo; one are taken from community cookbooks.</p>

<p>The main recipe contains machine/application specific setup:</p>

<p>```ruby</p>

<h1>chef/site-cookbooks/main/recipes/default.rb</h1>

<h1>setup</h1>

<p>rbenv_ruby node[&lsquo;ruby-version&rsquo;]
rbenv_global node[&lsquo;ruby-version&rsquo;]</p>

<p>rbenv_gem &lsquo;bundler&rsquo;</p>

<p>group &lsquo;admin&rsquo; do
  gid 420
end</p>

<p>user node[:user][:name] do
  password node[:user][:password]
  gid &lsquo;admin&rsquo;
  home &ldquo;/home/#{node[:user][:name]}&rdquo;
  shell &lsquo;/bin/bash&rsquo;
  supports :manage_home => true
end</p>

<p>directory &ldquo;#{node[:deploy_to]}/tmp/sockets&rdquo; do
  owner node[:user][:name]
  group &lsquo;admin&rsquo;
  recursive true
end</p>

<h1>certificates</h1>

<p>directory &ldquo;#{node[:deploy_to]}/certificate&rdquo; do
  owner node[:user][:name]
  recursive true
end</p>

<p>cookbook_file &ldquo;#{node[:deploy_to]}/certificate/#{node[:environment]}.crt&rdquo; do
  source &ldquo;#{node[:environment]}.crt&rdquo;
  action :create_if_missing
end</p>

<p>cookbook_file &ldquo;#{node[:deploy_to]}/certificate/#{node[:environment]}.key&rdquo; do
  source &ldquo;#{node[:environment]}.key&rdquo;
  action :create_if_missing
end</p>

<h1>configuration</h1>

<p>template &lsquo;/etc/nginx/sites-enabled/default&rsquo; do
  source &lsquo;nginx.erb&rsquo;
  owner &lsquo;root&rsquo;
  group &lsquo;root&rsquo;
  mode 0644
  notifies :restart, &lsquo;service[nginx]&rsquo;
end</p>

<p>[&ldquo;sv&rdquo;, &ldquo;service&rdquo;].each do |dir|
  directory &ldquo;/home/#{node[:user][:name]}/#{dir}&rdquo; do</p>

<pre><code>owner node[:user][:name]
group 'admin'
recursive true
</code></pre>

<p>  end
end</p>

<p>runit_service &ldquo;runsvdir-#{node[:user][:name]}&rdquo; do
  default_logger true
end</p>

<p>runit_service &lsquo;responsa&rsquo; do
  sv_dir &ldquo;/home/#{node[:user][:name]}/sv&rdquo;
  service_dir &ldquo;/home/#{node[:user][:name]}/service&rdquo;
  owner node[:user][:name]
  group &lsquo;admin&rsquo;
  restart_command &lsquo;2&rsquo;
  restart_on_update false
  default_logger true
end</p>

<p>service &lsquo;nginx&rsquo;
```</p>

<p>I&rsquo;m using runit to manage the unicorn service that is declared in a template file:</p>

<p>```</p>

<h1>chef/site-cookbooks/main/templates/default/sv-runsvdir-deployer-run.erb</h1>

<h1>!/bin/sh</h1>

<p>exec 2>&amp;1
exec chpst -u deployer runsvdir /home/deployer/service
```</p>

<p>```</p>

<h1>chef/site-cookbooks/main/templates/default/sv-responsa-run.erb</h1>

<h1>!/bin/bash</h1>

<p>exec 2>&amp;1</p>

<p>&lt;% unicorn_command = @options[:unicorn_command] || &lsquo;unicorn_rails&rsquo; &ndash;%></p>

<p>#</p>

<h1>Since unicorn creates a new pid on restart/reload, it needs a little extra love to</h1>

<h1>manage with runit. Instead of managing unicorn directly, we simply trap signal calls</h1>

<h1>to the service and redirect them to unicorn directly.</h1>

<p>function is_unicorn_alive {</p>

<pre><code>set +e
if [ -n $1 ] &amp;&amp; kill -0 $1 &gt;/dev/null 2&gt;&amp;1; then
    echo "yes"
fi
set -e
</code></pre>

<p>}</p>

<p>echo &ldquo;Service PID: $$&rdquo;</p>

<p>CUR_PID_FILE=/var/www/responsa/shared/pids/unicorn.pid
OLD_PID_FILE=$CUR_PID_FILE.oldbin</p>

<p>if [ -e $OLD_PID_FILE ]; then</p>

<pre><code>OLD_PID=$(cat $OLD_PID_FILE)
echo "Waiting for existing master ($OLD_PID) to exit"
while [ -n "$(is_unicorn_alive $OLD_PID)" ]; do
    /bin/echo -n '.'
    sleep 2
done
</code></pre>

<p>fi</p>

<p>if [ -e $CUR_PID_FILE ]; then</p>

<pre><code>CUR_PID=$(cat $CUR_PID_FILE)
if [ -n "$(is_unicorn_alive $CUR_PID)" ]; then
    echo "Unicorn master already running. PID: $CUR_PID"
    RUNNING=true
fi
</code></pre>

<p>fi</p>

<p>if [ ! $RUNNING ]; then</p>

<pre><code>echo "Starting unicorn"
cd /var/www/responsa/current
export PATH="/usr/local/rbenv/shims:/usr/local/rbenv/bin:$PATH"
# You need to daemonize the unicorn process, http://unicorn.bogomips.org/unicorn_rails_1.html
bundle exec &lt;%= unicorn_command %&gt; -c config/unicorn.rb -E &lt;%= @options[:environment] || 'staging' %&gt; -D
sleep 3
CUR_PID=$(cat $CUR_PID_FILE)
</code></pre>

<p>fi</p>

<p>function restart {</p>

<pre><code>echo "Initialize new master with USR2"
kill -USR2 $CUR_PID
# Make runit restart to pick up new unicorn pid
sleep 2
echo "Restarting service to capture new pid"
exit
</code></pre>

<p>}</p>

<p>function graceful_shutdown {</p>

<pre><code>echo "Initializing graceful shutdown"
kill -QUIT $CUR_PID
</code></pre>

<p>}</p>

<p>function unicorn_interrupted {</p>

<pre><code>echo "Unicorn process interrupted. Possibly a runit thing?"
</code></pre>

<p>}</p>

<p>trap restart HUP QUIT USR2 INT
trap graceful_shutdown TERM KILL
trap unicorn_interrupted ALRM</p>

<p>echo &ldquo;Waiting for current master to die. PID: ($CUR_PID)&rdquo;
while [ -n &ldquo;$(is_unicorn_alive $CUR_PID)&rdquo; ]; do</p>

<pre><code>/bin/echo -n '.'
sleep 2
</code></pre>

<p>done
echo &ldquo;You&rsquo;ve killed a unicorn!&rdquo;
```</p>

<p>Nginx is used as a reverse proxy:</p>

<p>```</p>

<h1>chef/site-cookbooks/main/templates/default/nginx.erb</h1>

<p>upstream unicorn {
  server unix:/var/www/responsa/tmp/sockets/responsa.sock fail_timeout=0;
}</p>

<p>server {
  listen 80;
  listen 443 default ssl;
  server_name &lt;%= node[:server_name] %>;
  root /var/www/responsa/current/public;
  # set far-future expiration headers on static content
  expires max;</p>

<p>  server_tokens off;</p>

<p>  # ssl                  on;
  ssl_certificate      &lt;%= &ldquo;/var/www/responsa/certificate/#{node[:environment]}.crt&rdquo; %>;
  ssl_certificate_key  &lt;%= &ldquo;/var/www/responsa/certificate/#{node[:environment]}.key&rdquo; %>;</p>

<p>  ssl_session_timeout  5m;</p>

<p>  ssl_protocols  SSLv2 SSLv3 TLSv1;
  ssl_ciphers  HIGH:!aNULL:!MD5;
  ssl_prefer_server_ciphers   on;</p>

<p>  # set up the rails servers as a virtual location for use later
  location @unicorn {</p>

<pre><code>proxy_set_header Host $host;
proxy_set_header X-Real-IP  $remote_addr;
proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
proxy_set_header X-Forwarded-Proto $scheme;
proxy_intercept_errors on;
proxy_redirect off;
proxy_pass http://unicorn;
expires off;
</code></pre>

<p>  }</p>

<p>  location / {</p>

<pre><code>try_files $uri @unicorn;
</code></pre>

<p>  }</p>

<p>  # error_page 500 502 503 504 /500.html;
}
```</p>

<p>And here&rsquo;s the unicorn configuration file:</p>

<p>```ruby</p>

<h1>config/unicorn.rb</h1>

<p>rails_env = ENV[&lsquo;RAILS_ENV&rsquo;] || &lsquo;production&rsquo;</p>

<p>worker_processes (rails_env == &lsquo;production&rsquo; ? 6 : 3)</p>

<p>preload_app true</p>

<h1>Restart any workers that haven&rsquo;t responded in 30 seconds</h1>

<p>timeout 30</p>

<p>working_directory &lsquo;/var/www/responsa/current&rsquo;</p>

<h1>Listen on a Unix data socket</h1>

<p>pid &lsquo;/var/www/responsa/shared/pids/unicorn.pid&rsquo;
listen &ldquo;/var/www/responsa/tmp/sockets/responsa.sock&rdquo;, :backlog => 2048</p>

<p>stderr_path &lsquo;/var/www/responsa/shared/log/unicorn.log&rsquo;
stdout_path &lsquo;/var/www/responsa/shared/log/unicorn.log&rsquo;</p>

<p>before_exec do |server|
  ENV[&ldquo;BUNDLE_GEMFILE&rdquo;] = &ldquo;/var/www/responsa/current/Gemfile&rdquo;
end</p>

<p>before_fork do |server, worker|
  ##
  # When sent a USR2, Unicorn will suffix its pidfile with .oldbin and
  # immediately start loading up a new version of itself (loaded with a new
  # version of our app). When this new Unicorn is completely loaded
  # it will begin spawning workers. The first worker spawned will check to
  # see if an .oldbin pidfile exists. If so, this means we&rsquo;ve just booted up
  # a new Unicorn and need to tell the old one that it can now die. To do so
  # we send it a QUIT.
  #
  # Using this method we get 0 downtime deploys.</p>

<p>  old_pid = &lsquo;/var/www/responsa/shared/pids/unicorn.pid.oldbin&rsquo;</p>

<p>  if File.exists?(old_pid) &amp;&amp; server.pid != old_pid</p>

<pre><code>begin
  Process.kill("QUIT", File.read(old_pid).to_i)
rescue Errno::ENOENT, Errno::ESRCH
  # someone else did our job for us
end
</code></pre>

<p>  end
end
```</p>

<h2>Capistrano</h2>

<p>After setting up the machine I created a snapshot on Digital Ocean, in case I had to restart from scratch.</p>

<p>Time to deploy! Capistrano was an easy choice.</p>

<p>Using Capistrano multistage I set up the production script</p>

<p>```ruby</p>

<h1>config/deploy/production.rb</h1>

<p>set :server_ip, $MY_IP
server server_ip, :app, :web, :primary => true
set :rails_env, &lsquo;production&rsquo;
set :branch, &lsquo;master&rsquo;
```</p>

<p>This is used in combo with the deploy script:</p>

<p>```ruby</p>

<h1>config/deploy.rb</h1>

<p>require &lsquo;bundler/capistrano&rsquo;
require &lsquo;sidekiq/capistrano&rsquo;
require &lsquo;capistrano/ext/multistage&rsquo;</p>

<p>set :stages, %w(production staging)
set :default_stage, &lsquo;staging&rsquo;</p>

<p>default_run_options[:pty] = true
ssh_options[:forward_agent] = true</p>

<p>set :application, &lsquo;responsa&rsquo;
set :repository,  $PATH_TO_GITHUB_REPO
set :deploy_to, &ldquo;/var/www/#{application}&rdquo;
set :branch, &lsquo;development&rsquo;</p>

<p>set :scm, :git
set :scm_verbose, true</p>

<p>set :deploy_via, :remote_cache
set :use_sudo, true
set :keep_releases, 3
set :user, &lsquo;deployer&rsquo;</p>

<p>set :bundle_without, [:development, :test, :acceptance]</p>

<p>set :rake, &ldquo;#{rake} &mdash;trace&rdquo;</p>

<p>set :default_environment, {
  &lsquo;PATH&rsquo; => &lsquo;/usr/local/rbenv/shims:/usr/local/rbenv/bin:$PATH&rsquo;
}</p>

<p>after &lsquo;deploy:update_code&rsquo;, :upload_env_vars</p>

<p>after &lsquo;deploy:setup&rsquo; do
  sudo &ldquo;chown -R #{user} #{deploy_to} &amp;&amp; chmod -R g+s #{deploy_to}&rdquo;
end</p>

<p>namespace :deploy do
  desc &lt;&lt;-DESC
  Send a USR2 to the unicorn process to restart for zero downtime deploys.
  runit expects 2 to tell it to send the USR2 signal to the process.
  DESC
  task :restart, :roles => :app, :except => { :no_release => true } do</p>

<pre><code>run "sv 2 /home/#{user}/service/#{application}"
</code></pre>

<p>  end
end</p>

<p>task :upload_env_vars do
  upload(&ldquo;.env.#{rails_env}&rdquo;, &ldquo;#{release_path}/.env.#{rails_env}&rdquo;, :via => :scp)
end
```</p>

<p>Now with two simple commands I can deploy with 0 downtime!</p>

<p><code>
cap deploy:setup
cap deploy
</code></p>

<p>I must thank czarneckid for sharing <a href="https://gist.github.com/czarneckid/4639793">his setup on Github</a> from which I stole some useful portions and also <a href="https://twitter.com/bugant">@bugant</a> for his patience.</p>
]]></content>
  </entry>
  
</feed>
