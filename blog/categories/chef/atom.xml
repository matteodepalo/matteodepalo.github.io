<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: chef | Matteo Depalo's Blog]]></title>
  <link href="http://matteodepalo.github.io/blog/categories/chef/atom.xml" rel="self"/>
  <link href="http://matteodepalo.github.io/"/>
  <updated>2014-01-03T17:50:03+01:00</updated>
  <id>http://matteodepalo.github.io/</id>
  <author>
    <name><![CDATA[Matteo Depalo]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[How I migrated from Heroku to Digital Ocean with Chef and Capistrano]]></title>
    <link href="http://matteodepalo.github.io/blog/2013/03/07/how-i-migrated-from-heroku-to-digital-ocean-with-chef-and-capistrano/"/>
    <updated>2013-03-07T11:24:00+01:00</updated>
    <id>http://matteodepalo.github.io/blog/2013/03/07/how-i-migrated-from-heroku-to-digital-ocean-with-chef-and-capistrano</id>
    <content type="html"><![CDATA[<p>UPDATE:</p>

<ul>
<li>Removed ElasticSearch and MongoDB recipes since they were not so useful for this tutorial.</li>
<li>Added unicorn.rb</li>
<li>Added ssh authentication step</li>
<li>Added file paths</li>
</ul>


<p>I&rsquo;ve always loved deploying to Heroku. The simplicity of a git push let me focus on developing my applications which is what I really care about. However, both because of the <a href="http://rapgenius.com/James-somers-herokus-ugly-secret-lyrics">scandal about the routing system</a> and because I wanted to expand my skill set by entering the sysadmin land, at <a href="https://goresponsa.com">Responsa</a> I decided to migrate to a VPS solution.</p>

<p>At this point I had three choices to make:</p>

<ol>
<li>Hosting provider</li>
<li>Technology stack</li>
<li>Deploy strategy</li>
</ol>


<h2>Provider</h2>

<p>Many hackers I follow were recommending <a href="https://www.digitalocean.com/">Digital Ocean</a> so I gave it a try. I must say I was very impressed with the simplicity and power of their dashboard, so I decided to use it.</p>

<p>I immediately changed my root password</p>

<p><code>
passwd
</code></p>

<p>Copied over my ssh key with</p>

<p><code>
ssh-copy-id root@$IP
</code></p>

<p>And disabled password access setting <code>PasswordAuthentication no</code> in <code>/etc/ssh/sshd_config</code></p>

<h2>Technology</h2>

<p>The decision of the web server was also quick. I wanted to achieve 0 downtime deployments so Github use of <a href="https://github.com/blog/517-unicorn">Unicorn + Nginx</a> jumped to my mind.</p>

<h2>Deploy strategy</h2>

<p>This is where things got a little bit complicated. Disclaimer: I&rsquo;m not a Linux/Unix pro, so many system administration practices where unknown to me prior to this week. Having said that, It was clear to me that the community is very fragmented. There were so many solutions to the same problems and so many scripts! After digging, trying and failing miserably I settled on the stack that caused me the least suffering:</p>

<ol>
<li>Chef solo and Knife for the machine provisioning</li>
<li>Capistrano for the deployment</li>
</ol>


<h2>Chef</h2>

<p><a href="http://www.opscode.com/chef/">Chef</a> is a provisioning tool written in Ruby. Its DSL is very expressive and powerful. The community is full of useful cookbooks that ease the setup of common services, however it seemed to lack a way to handle community cookbooks. This is where <a href="https://github.com/applicationsonline/librarian-chef">Librarian Chef</a> comes in. I just had to write a Cheffile with all the dependencies and I was done.</p>

<p>```ruby</p>

<h1>Cheffile</h1>

<h1>!/usr/bin/env ruby</h1>

<h1>^syntax detection</h1>

<p>site &lsquo;<a href="http://community.opscode.com/api/v1">http://community.opscode.com/api/v1</a>&rsquo;</p>

<p>cookbook &lsquo;libqt4&rsquo;,
  :git => &lsquo;<a href="https://github.com/phlipper/chef-libqt4">https://github.com/phlipper/chef-libqt4</a>&rsquo;</p>

<p>cookbook &lsquo;nodejs&rsquo;
cookbook &lsquo;nginx&rsquo;
cookbook &lsquo;runit&rsquo;
cookbook &lsquo;java&rsquo;
cookbook &lsquo;imagemagick&rsquo;
cookbook &lsquo;vim&rsquo;
cookbook &lsquo;ruby_build&rsquo;, :git => &lsquo;git://github.com/fnichol/chef-ruby_build.git&rsquo;
cookbook &lsquo;rbenv&rsquo;, :git => &lsquo;git://github.com/fnichol/chef-rbenv.git&rsquo;
cookbook &lsquo;redis&rsquo;, :git => &lsquo;git://github.com/cassianoleal/chef-redis.git&rsquo;
cookbook &lsquo;memcached&rsquo;
```</p>

<p>To bootstrap the machine with Chef and Ruby many people where using custom Knife templates that were not working for me. Some installed ruby with RVM, others with rbenv. In the end I found <a href="http://matschaffer.github.com/knife-solo/">Knife Solo</a> that solved all my problems. With one command after the initialization I could install Chef AND run all my recipes to install Ruby and every other service I needed.</p>

<p><code>
knife solo init
knife solo bootstrap root@$IP node.json
</code></p>

<p>Librarian and Knife Solo forced me to use a specific project structure:</p>

<p><code>
mychefrepo/
├── cookbooks
├── site-cookbooks
├── Cheffile
├── Cheffile.lock
└── node.json
</code></p>

<p>The node.json contains the run list of recipes:</p>

<p>```json
{
  &ldquo;user&rdquo;: {</p>

<pre><code>"name": "deployer",
"password": $PASSWORD
</code></pre>

<p>  },
  &ldquo;environment&rdquo;: &ldquo;production&rdquo;,
  &ldquo;server_name&rdquo;: &ldquo;goresponsa.com&rdquo;,
  &ldquo;deploy_to&rdquo;: &ldquo;/var/www/responsa&rdquo;,
  &ldquo;ruby-version&rdquo;: &ldquo;1.9.3-p286&rdquo;,
  &ldquo;run_list&rdquo;: [</p>

<pre><code>"recipe[vim]",
"recipe[libqt4]",
"recipe[imagemagick]",
"recipe[java]",
"recipe[redis::source]",
"recipe[memcached]",
"recipe[nodejs]",
"recipe[ruby_build]",
"recipe[rbenv::system]",
"recipe[runit]",
"recipe[nginx]",
"recipe[main]"
</code></pre>

<p>  ]
}
```</p>

<p>All recipes except the &ldquo;main&rdquo; one are taken from community cookbooks.</p>

<p>The main recipe contains machine/application specific setup:</p>

<p>```ruby</p>

<h1>chef/site-cookbooks/main/recipes/default.rb</h1>

<h1>setup</h1>

<p>rbenv_ruby node[&lsquo;ruby-version&rsquo;]
rbenv_global node[&lsquo;ruby-version&rsquo;]</p>

<p>rbenv_gem &lsquo;bundler&rsquo;</p>

<p>group &lsquo;admin&rsquo; do
  gid 420
end</p>

<p>user node[:user][:name] do
  password node[:user][:password]
  gid &lsquo;admin&rsquo;
  home &ldquo;/home/#{node[:user][:name]}&rdquo;
  shell &lsquo;/bin/bash&rsquo;
  supports :manage_home => true
end</p>

<p>directory &ldquo;#{node[:deploy_to]}/tmp/sockets&rdquo; do
  owner node[:user][:name]
  group &lsquo;admin&rsquo;
  recursive true
end</p>

<h1>certificates</h1>

<p>directory &ldquo;#{node[:deploy_to]}/certificate&rdquo; do
  owner node[:user][:name]
  recursive true
end</p>

<p>cookbook_file &ldquo;#{node[:deploy_to]}/certificate/#{node[:environment]}.crt&rdquo; do
  source &ldquo;#{node[:environment]}.crt&rdquo;
  action :create_if_missing
end</p>

<p>cookbook_file &ldquo;#{node[:deploy_to]}/certificate/#{node[:environment]}.key&rdquo; do
  source &ldquo;#{node[:environment]}.key&rdquo;
  action :create_if_missing
end</p>

<h1>configuration</h1>

<p>template &lsquo;/etc/nginx/sites-enabled/default&rsquo; do
  source &lsquo;nginx.erb&rsquo;
  owner &lsquo;root&rsquo;
  group &lsquo;root&rsquo;
  mode 0644
  notifies :restart, &lsquo;service[nginx]&rsquo;
end</p>

<p>[&ldquo;sv&rdquo;, &ldquo;service&rdquo;].each do |dir|
  directory &ldquo;/home/#{node[:user][:name]}/#{dir}&rdquo; do</p>

<pre><code>owner node[:user][:name]
group 'admin'
recursive true
</code></pre>

<p>  end
end</p>

<p>runit_service &ldquo;runsvdir-#{node[:user][:name]}&rdquo; do
  default_logger true
end</p>

<p>runit_service &lsquo;responsa&rsquo; do
  sv_dir &ldquo;/home/#{node[:user][:name]}/sv&rdquo;
  service_dir &ldquo;/home/#{node[:user][:name]}/service&rdquo;
  owner node[:user][:name]
  group &lsquo;admin&rsquo;
  restart_command &lsquo;2&rsquo;
  restart_on_update false
  default_logger true
end</p>

<p>service &lsquo;nginx&rsquo;
```</p>

<p>I&rsquo;m using runit to manage the unicorn service that is declared in a template file:</p>

<p>```</p>

<h1>chef/site-cookbooks/main/templates/default/sv-runsvdir-deployer-run.erb</h1>

<h1>!/bin/sh</h1>

<p>exec 2>&amp;1
exec chpst -u deployer runsvdir /home/deployer/service
```</p>

<p>```</p>

<h1>chef/site-cookbooks/main/templates/default/sv-responsa-run.erb</h1>

<h1>!/bin/bash</h1>

<p>exec 2>&amp;1</p>

<p>&lt;% unicorn_command = @options[:unicorn_command] || &lsquo;unicorn_rails&rsquo; &ndash;%></p>

<p>#</p>

<h1>Since unicorn creates a new pid on restart/reload, it needs a little extra love to</h1>

<h1>manage with runit. Instead of managing unicorn directly, we simply trap signal calls</h1>

<h1>to the service and redirect them to unicorn directly.</h1>

<p>function is_unicorn_alive {</p>

<pre><code>set +e
if [ -n $1 ] &amp;&amp; kill -0 $1 &gt;/dev/null 2&gt;&amp;1; then
    echo "yes"
fi
set -e
</code></pre>

<p>}</p>

<p>echo &ldquo;Service PID: $$&rdquo;</p>

<p>CUR_PID_FILE=/var/www/responsa/shared/pids/unicorn.pid
OLD_PID_FILE=$CUR_PID_FILE.oldbin</p>

<p>if [ -e $OLD_PID_FILE ]; then</p>

<pre><code>OLD_PID=$(cat $OLD_PID_FILE)
echo "Waiting for existing master ($OLD_PID) to exit"
while [ -n "$(is_unicorn_alive $OLD_PID)" ]; do
    /bin/echo -n '.'
    sleep 2
done
</code></pre>

<p>fi</p>

<p>if [ -e $CUR_PID_FILE ]; then</p>

<pre><code>CUR_PID=$(cat $CUR_PID_FILE)
if [ -n "$(is_unicorn_alive $CUR_PID)" ]; then
    echo "Unicorn master already running. PID: $CUR_PID"
    RUNNING=true
fi
</code></pre>

<p>fi</p>

<p>if [ ! $RUNNING ]; then</p>

<pre><code>echo "Starting unicorn"
cd /var/www/responsa/current
export PATH="/usr/local/rbenv/shims:/usr/local/rbenv/bin:$PATH"
# You need to daemonize the unicorn process, http://unicorn.bogomips.org/unicorn_rails_1.html
bundle exec &lt;%= unicorn_command %&gt; -c config/unicorn.rb -E &lt;%= @options[:environment] || 'staging' %&gt; -D
sleep 3
CUR_PID=$(cat $CUR_PID_FILE)
</code></pre>

<p>fi</p>

<p>function restart {</p>

<pre><code>echo "Initialize new master with USR2"
kill -USR2 $CUR_PID
# Make runit restart to pick up new unicorn pid
sleep 2
echo "Restarting service to capture new pid"
exit
</code></pre>

<p>}</p>

<p>function graceful_shutdown {</p>

<pre><code>echo "Initializing graceful shutdown"
kill -QUIT $CUR_PID
</code></pre>

<p>}</p>

<p>function unicorn_interrupted {</p>

<pre><code>echo "Unicorn process interrupted. Possibly a runit thing?"
</code></pre>

<p>}</p>

<p>trap restart HUP QUIT USR2 INT
trap graceful_shutdown TERM KILL
trap unicorn_interrupted ALRM</p>

<p>echo &ldquo;Waiting for current master to die. PID: ($CUR_PID)&rdquo;
while [ -n &ldquo;$(is_unicorn_alive $CUR_PID)&rdquo; ]; do</p>

<pre><code>/bin/echo -n '.'
sleep 2
</code></pre>

<p>done
echo &ldquo;You&rsquo;ve killed a unicorn!&rdquo;
```</p>

<p>Nginx is used as a reverse proxy:</p>

<p>```</p>

<h1>chef/site-cookbooks/main/templates/default/nginx.erb</h1>

<p>upstream unicorn {
  server unix:/var/www/responsa/tmp/sockets/responsa.sock fail_timeout=0;
}</p>

<p>server {
  listen 80;
  listen 443 default ssl;
  server_name &lt;%= node[:server_name] %>;
  root /var/www/responsa/current/public;
  # set far-future expiration headers on static content
  expires max;</p>

<p>  server_tokens off;</p>

<p>  # ssl                  on;
  ssl_certificate      &lt;%= &ldquo;/var/www/responsa/certificate/#{node[:environment]}.crt&rdquo; %>;
  ssl_certificate_key  &lt;%= &ldquo;/var/www/responsa/certificate/#{node[:environment]}.key&rdquo; %>;</p>

<p>  ssl_session_timeout  5m;</p>

<p>  ssl_protocols  SSLv2 SSLv3 TLSv1;
  ssl_ciphers  HIGH:!aNULL:!MD5;
  ssl_prefer_server_ciphers   on;</p>

<p>  # set up the rails servers as a virtual location for use later
  location @unicorn {</p>

<pre><code>proxy_set_header Host $host;
proxy_set_header X-Real-IP  $remote_addr;
proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
proxy_set_header X-Forwarded-Proto $scheme;
proxy_intercept_errors on;
proxy_redirect off;
proxy_pass http://unicorn;
expires off;
</code></pre>

<p>  }</p>

<p>  location / {</p>

<pre><code>try_files $uri @unicorn;
</code></pre>

<p>  }</p>

<p>  # error_page 500 502 503 504 /500.html;
}
```</p>

<p>And here&rsquo;s the unicorn configuration file:</p>

<p>```ruby</p>

<h1>config/unicorn.rb</h1>

<p>rails_env = ENV[&lsquo;RAILS_ENV&rsquo;] || &lsquo;production&rsquo;</p>

<p>worker_processes (rails_env == &lsquo;production&rsquo; ? 6 : 3)</p>

<p>preload_app true</p>

<h1>Restart any workers that haven&rsquo;t responded in 30 seconds</h1>

<p>timeout 30</p>

<p>working_directory &lsquo;/var/www/responsa/current&rsquo;</p>

<h1>Listen on a Unix data socket</h1>

<p>pid &lsquo;/var/www/responsa/shared/pids/unicorn.pid&rsquo;
listen &ldquo;/var/www/responsa/tmp/sockets/responsa.sock&rdquo;, :backlog => 2048</p>

<p>stderr_path &lsquo;/var/www/responsa/shared/log/unicorn.log&rsquo;
stdout_path &lsquo;/var/www/responsa/shared/log/unicorn.log&rsquo;</p>

<p>before_exec do |server|
  ENV[&ldquo;BUNDLE_GEMFILE&rdquo;] = &ldquo;/var/www/responsa/current/Gemfile&rdquo;
end</p>

<p>before_fork do |server, worker|
  ##
  # When sent a USR2, Unicorn will suffix its pidfile with .oldbin and
  # immediately start loading up a new version of itself (loaded with a new
  # version of our app). When this new Unicorn is completely loaded
  # it will begin spawning workers. The first worker spawned will check to
  # see if an .oldbin pidfile exists. If so, this means we&rsquo;ve just booted up
  # a new Unicorn and need to tell the old one that it can now die. To do so
  # we send it a QUIT.
  #
  # Using this method we get 0 downtime deploys.</p>

<p>  old_pid = &lsquo;/var/www/responsa/shared/pids/unicorn.pid.oldbin&rsquo;</p>

<p>  if File.exists?(old_pid) &amp;&amp; server.pid != old_pid</p>

<pre><code>begin
  Process.kill("QUIT", File.read(old_pid).to_i)
rescue Errno::ENOENT, Errno::ESRCH
  # someone else did our job for us
end
</code></pre>

<p>  end
end
```</p>

<h2>Capistrano</h2>

<p>After setting up the machine I created a snapshot on Digital Ocean, in case I had to restart from scratch.</p>

<p>Time to deploy! Capistrano was an easy choice.</p>

<p>Using Capistrano multistage I set up the production script</p>

<p>```ruby</p>

<h1>config/deploy/production.rb</h1>

<p>set :server_ip, $MY_IP
server server_ip, :app, :web, :primary => true
set :rails_env, &lsquo;production&rsquo;
set :branch, &lsquo;master&rsquo;
```</p>

<p>This is used in combo with the deploy script:</p>

<p>```ruby</p>

<h1>config/deploy.rb</h1>

<p>require &lsquo;bundler/capistrano&rsquo;
require &lsquo;sidekiq/capistrano&rsquo;
require &lsquo;capistrano/ext/multistage&rsquo;</p>

<p>set :stages, %w(production staging)
set :default_stage, &lsquo;staging&rsquo;</p>

<p>default_run_options[:pty] = true
ssh_options[:forward_agent] = true</p>

<p>set :application, &lsquo;responsa&rsquo;
set :repository,  $PATH_TO_GITHUB_REPO
set :deploy_to, &ldquo;/var/www/#{application}&rdquo;
set :branch, &lsquo;development&rsquo;</p>

<p>set :scm, :git
set :scm_verbose, true</p>

<p>set :deploy_via, :remote_cache
set :use_sudo, true
set :keep_releases, 3
set :user, &lsquo;deployer&rsquo;</p>

<p>set :bundle_without, [:development, :test, :acceptance]</p>

<p>set :rake, &ldquo;#{rake} &mdash;trace&rdquo;</p>

<p>set :default_environment, {
  &lsquo;PATH&rsquo; => &lsquo;/usr/local/rbenv/shims:/usr/local/rbenv/bin:$PATH&rsquo;
}</p>

<p>after &lsquo;deploy:update_code&rsquo;, :upload_env_vars</p>

<p>after &lsquo;deploy:setup&rsquo; do
  sudo &ldquo;chown -R #{user} #{deploy_to} &amp;&amp; chmod -R g+s #{deploy_to}&rdquo;
end</p>

<p>namespace :deploy do
  desc &lt;&lt;-DESC
  Send a USR2 to the unicorn process to restart for zero downtime deploys.
  runit expects 2 to tell it to send the USR2 signal to the process.
  DESC
  task :restart, :roles => :app, :except => { :no_release => true } do</p>

<pre><code>run "sv 2 /home/#{user}/service/#{application}"
</code></pre>

<p>  end
end</p>

<p>task :upload_env_vars do
  upload(&ldquo;.env.#{rails_env}&rdquo;, &ldquo;#{release_path}/.env.#{rails_env}&rdquo;, :via => :scp)
end
```</p>

<p>Now with two simple commands I can deploy with 0 downtime!</p>

<p><code>
cap deploy:setup
cap deploy
</code></p>

<p>I must thank czarneckid for sharing <a href="https://gist.github.com/czarneckid/4639793">his setup on Github</a> from which I stole some useful portions and also <a href="https://twitter.com/bugant">@bugant</a> for his patience.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Cube loves Geckoboard]]></title>
    <link href="http://matteodepalo.github.io/blog/2012/07/23/cube-loves-geckoboard/"/>
    <updated>2012-07-23T12:02:00+02:00</updated>
    <id>http://matteodepalo.github.io/blog/2012/07/23/cube-loves-geckoboard</id>
    <content type="html"><![CDATA[<h2>Introduction</h2>

<p>This is a summary of my experiences and a mini-guide regarding the deploying and usage of a Cube server and Geckoboard to track statistics at Responsa.</p>

<p>I&rsquo;ll explain how I deployed Cube to a VPS in the cloud and how I&rsquo;ve integrated it in Responsa. I&rsquo;ll also talk about Geckoboard and how we used it to draw graphs based on metrics extracted from Cube, but first here&rsquo;s a brief description of Cube and Geckoboard.</p>

<h3>Cube</h3>

<p><a href="http://square.github.com/cube/">Cube</a> is a system for collecting timestamped events and deriving metrics. By collecting events rather than metrics, Cube lets you compute aggregate statistics post hoc. It also enables richer analysis, such as quantiles and histograms of arbitrary event sets.</p>

<h3>Geckoboard</h3>

<p><a href="http://www.geckoboard.com">Geckoboard</a> is a service for drawing graphs and statistics and organizing them in widgets that populate dashboards.</p>

<h2>Deploying</h2>

<p>To deploy the Cube server I&rsquo;ve chosen Linode, a service that gives you an empty Ubuntu Server virtual machine in the cloud. After the creation of the machine you can just ssh inside and start installing your server.</p>

<p>To make the deploying process automatic I&rsquo;ve chosen <a href="http://wiki.opscode.com/display/chef/About">chef</a>, and in particular <a href="http://wiki.opscode.com/display/chef/Chef+Solo">chef-solo</a>.</p>

<p>Since chef uses ruby we need to install it first in our machine so just run these commands to get some basic stuff:</p>

<p><code>bash
apt-get -y update
apt-get -y install curl git-core python-software-properties
</code></p>

<p><code>bash
curl -L https://raw.github.com/fesplugas/rbenv-installer/master/bin/rbenv-installer | bash
vim ~/.bashrc # add rbenv to the top
. ~/.bashrc
rbenv bootstrap-ubuntu-10-04
rbenv install 1.9.3-p125
rbenv global 1.9.3-p125
gem install bundler --no-ri --no-rdoc
rbenv rehash
</code></p>

<p>Then you can install Cube with:</p>

<p><code>bash
git clone git://github.com/matteodepalo/cube.git
cd cube
</code></p>

<p>Now all you need to do is to download the cookbooks and run chef:</p>

<p><code>bash
gem install librarian
librarian-chef install
chef-solo -c solo.rb
</code></p>

<p>And your Cube server should be up and running ready to track events!</p>

<h2>Tracking events</h2>

<p>We use Ruby on Rails as our stack so I&rsquo;ve chosen the <a href="https://github.com/codykrieger/cube-ruby">cube-ruby</a> gem to communicate with the server. With this gem you can talk with the <a href="https://github.com/square/cube/wiki/Collector">Cube collector</a> in order to track events.</p>

<p>For example if we want to track a request we can write:</p>

<p><code>ruby
$cube = Cube::Client.new 'your-host.com'
$cube.send "request", :value =&gt; 'somevalue'
</code></p>

<h2>Analysis</h2>

<p>To compute metrics I&rsquo;ve created a ruby gem called <a href="https://github.com/matteodepalo/cube-evaluator">cube-evaluator</a>, which talks with the <a href="https://github.com/square/cube/wiki/Collector">Cube evaluator</a>.</p>

<p>Let&rsquo;s say we want the daily requests on our website in this month we can write:</p>

<p>```ruby
$cube_evaluator = Cube::Evaluator.new &lsquo;your-host.com&rsquo;
daily_requests = $cube_evaluator.metric(</p>

<pre><code>               :expression =&gt; 'sum(request)',
               :start =&gt; 1.month.ago,
               :stop =&gt; Time.now,
               :step =&gt; '1day'
             )
</code></pre>

<p>```</p>

<p><code>daily_requests</code> will be an Hash containing the array of times and the array of corresponding values</p>

<h2>Drawing</h2>

<p>Geckoboard needs an endpoint in your server to poll in order to draw the data. To ease the creation of these endpoints I&rsquo;ve improved and used the <a href="https://github.com/matteodepalo/chameleon">chameleon gem</a>. Just add it to your gemfile</p>

<p><code>ruby
gem 'chameleon', :git =&gt; 'git://github.com/matteodepalo/chameleon.git'
</code></p>

<p>then run bundle to install it</p>

<p><code>bash
bundle install
</code></p>

<p>Let&rsquo;s draw the daily_requests now. Create a line widget graph</p>

<p><code>bash
rails g chameleon:widget requests line
</code></p>

<p>and use your daily_requests hash to populate it</p>

<p>```ruby
Chameleon::Widget.new :requests do
  key &ldquo;3618c90ec02d5a57061ad7b78afcbb050e50b608&rdquo;
  type &ldquo;line&rdquo;
  data do</p>

<pre><code>{
  :items =&gt; daily_requests[:values],
  :x_axis =&gt; daily_requests[:times],
  :y_axis =&gt; [daily_requests[:times].min, daily_requests[:times].max]
}
</code></pre>

<p>  end
end
```</p>

<p>Congrats! You are now tracking statistics in the coolest way possible ;)</p>
]]></content>
  </entry>
  
</feed>
